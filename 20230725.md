# Data Structure

## set
- 고유한 항목들(중복이 없는)의 정렬되지 않은 컬렉션

### 세트 메서드
```python
# .add(x)
# 세트 s에 항목 x를 추가. 이미 x가 있다면 변화 없음
my_set = {1, 2, 3}
my_set.add(4)
print(my_set) # {1, 2, 3, 4}

my_set.add(4)
print(my_set) # {1, 2, 3, 4} / 중복을 허용하지 않음

# .clear()
# 세트 s의 모든 항목을 제거
my_set = {1, 2, 3}
my_set.clear()
print(my_set) # set()
# {}는 빈 딕셔너리이기 때문에 빈 세트는 set()

# .remove(x)
# 세트에서 항목 x를 제거
my_set = {1, 2, 3}
my_set.remove(2)
print(my_set) # {1, 3}

# my_set.remove(10)
# print(my_set) # KeyError

# .pop()
# 세트에서 '임의의' 요소를 제거하고 '반환'
# 순서가 없기 때문에 '임의'의 요소를 제거
# 실행할 때마다 다른 요소를 얻는다는 의미에서의 '무작위'가 아니라 '임의' 라는 의미에서 '무작위'
# By "arbitarary" the docs don't mean "random"
# 순서가 있진 않지만 '정수'에 대한 동작은 인터프리터 환경에서 해시 테이블에 저장되어 있는 순서는 존재!
# 정수 값은 그 자체 값이 해시 값이 됨
# 문자열은 실행시마다 다른 해시 테이블에 저장되는 위치가 매번 달라진다
my_set = {1, 2, 3}
element = my_set.pop()

# .discard(x)
# 세트 s에서 항목 x를 제거 remove와 달리 에러 없음
my_set = {1, 2, 3}
my_set.discard(2)
print(my_set) # {1, 3}

print(my_set.discard(10)) # None / 에러를 발생시키지 않고 별도의 반환도 존재하지 않는다

# .update(iterable)
# 세트에 다른 iterable 요소를 추가
# 반복 가능한 요소를 풀어서 추가
my_set = {1, 2, 3}
my_set.ipdate([4, 5, 1])
print(my_set) # {1, 2, 3, 4, 5}
```

### 세트의 집합 메서드

#### set1.difference(set2)
- set1에는 들어 있지만 set2에는 없는 항목으로 세트를 생성 후 반환
  
-  차집합

- 연산자 : set1 - set2

#### set1.intersection(set2)
- set1과 set2 모두 들어 있는 항목으로 세트를 생성 후 반환

- 교집합

- 연산자 : set1 & set2

#### set.issubset(set2)
- set1의 항목이 모두 set2에 들어 있으면 True를 반환

- 연산자 set <= set2

#### set.issuperset(set2)
- set1가 set2의 항목을 모두 포함하면 True를 반환

- d연산자 set1 >= set2

#### set1.union(set2)
- set1 또는 set2에 (혹은 둘 다) 들어있는 항목으로 세트를 생성 후 반환

- 합집합

- 연산자 : set1 | set2
  
## 딕셔너리

### 딕셔너리 메서드

```python
# .clear()
# 딕셔너리의 모든 키/값 쌍을 제거

# .get(key[,default])
# 키 연결된 값을 반환하거나 키가 없으면 None 혹은 기본 값을 반환

person = {'name' : 'Alice', 'age' : 25}

print(person.get('name')) #Alice
print(person.get('country')) #None
print(person.get('country', 'Unknown')) #Unkonown

# print(my_dict['name']) 과 결과는 같음
# but 찾고자 하는 키가 없을 때 KeyError 발생
# .get은 None을 반환 / 또는 반환 값을 컨트롤 할 수 있음

# .keys()
# 딕셔너리 키를 모은 객체를 반환

person = {'name' : 'Alice', 'age' : 25}
print(person.keys()) #dict_keys(['name', 'age'])

for k in person.keys():
    print(k)
"""
name
age
"""

# .values()
# 딕셔너리 값을 모은 객체를 반환

person = {'name' : 'Alice', 'age' : 25}
print(person.values()) #dict_values(['Alice', '25'])

for v in person.keys():
    print(v)
"""
Alice
25
"""

# .items()
# 딕셔너리 키/값 쌍을 모은 객체를 변환

person = {'name' : 'Alice', 'age' : 25}
print(person.items()) #dict_items([('name', 'Alice')] [('age', 25)])
# 튜플로 출력

for k, v in person.items():
    print(k, v)
"""
name Alice
age 25
"""
```