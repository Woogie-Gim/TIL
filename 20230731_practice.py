# pypy 3 는 보통 파이썬 보다는 빠른
# 문제풀이 시 파이썬일 때 시간초과될 경우가 있음

# 누구의 코드가 더 효율적인가?
# 1. 누가 더 빠른 실행속도를 가졌는가 -> 시간 복잡도
# 2. 누가 더 적은 메모리를 사용했는가 -> 공간 복잡도

# Time Complexity (시간복잡도)
# 대략적으로 계산하는 점근적 표기법
# 시간복잡도 = 기본연산 수행 횟수 + 입력되는 data를 종합적으로 고려를 하는 대략적인 계산 방법
# -> 점근적 표기법



# 입력되는 data를 최선 표기법, 최악 표기법,평균 표기법
# 최선 표기법 : 코드가 최소한으로 실행 될 값이 들어왔다고 가정
# 최악 표기법 : 코드가 최대한으로 실행 될 값이 들어왔다고 가정
# 평균 표기법 : 두 비교 값의 평균으로 실행

# 시간 복잡도를 계산할 때 problem solving 분야에선 최악 표기법을 통해서 비교를 할 예정
# 빅오표기법 Order

n = int(input())
a = 10
b = 20

for _ in range(n):
    print('#')

print(a)
# 최소한 실행된다면 n = 0 을 입력 4번 실행
# 입력받는 데이터가 어떤 값이냐에 따라서 시간 복잡도 계산이 달라짐

# O(n + 4)
# 파이썬에선 무한대의 정수 값을 입력받을 수 있는데 예를 들어 21억이 입력이 되었을 때
# 21억에 비하면 4는 의미없는 값 +4 는 무시가 되어버린다
# 위 코드의 시간복잡도는 O(n)의 속도가 난다

n = int(input())
a, b = 10, 20


for _ in range(3):
    print('#')

print(a)

# O(6)
# O(1) 대략적인 계산이기 때문에
# 입력받은 숫자로 인한 계산이 없다면 전부 O(1)

n = int(input())
m = int(input())

a, b = 10, 20


for _ in range(n):
    print('#')

for _ in range(m):
    print('@')

print(a)

# O(2n) -> O(n)

n = int(input())
m = int(input())

a, b = 10, 20

for _ in range(n):
    for _ in range(m):
        print('#')

print(a)

# O(n ** 2)

"""
n = int(input())
m = int(input())

def abc(n):
    for i in range(n):
        print('#')

for i in range(m):
    abc(n):

# O(n ** 2)
"""

# 빅오표기법 때 상수 계수 싹다 무시

# O(logN) log2 에서 2 가 생략 되어 있음
# O(NlogN)

# n개의 정수가 있는데
# [5, 3, 7, 9, 1, 2, 6] 7개
# 트리에 저장을 할 때
# 5보다 작으면 왼쪽 / 크면 오른쪽
#         5
#        3   7
#       1 4   9
#               6
# 비선형구조 트리에 저장했다고 가정
# 8을 탐색할 때 5보다 크니 오른쪽 탐색 -> 7보다 크니 오른쪽 탐색 -> 9보다 작지만 왼쪽이 없으니 3번만 탐색
# log(2)N = 탐색 횟수 (N = 탐색해야 할 data 수)
# O(logN) 의 시간 복잡도 속도가 난다
# logN을 N번 반복하면 O(NlogN)
# sort / sorted 내장 알고리즘의 속도가 O(NlogN)

# 문제 풀 때 시간복잡도 먼저 계산해야함
# -> 몇중 for문 까지 사용해도 되는 지가 확인이 됨